#include "CppUnitTest.h"
#include "../Plato/Quaternion.h"
#include "../Tornado/Similar.h"
#include "../_TestingUtilities/HandyMacros.h"
#include <random>
#include <sstream>

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace TransformRelated
{
	TEST_CLASS(_Quaternion)
	{
	private:
		std::mt19937 rng;

	public:
		// Constructor
		_Quaternion()
		{
			rng = std::mt19937((std::random_device())());
			return;
		}

		// Tests that if constructed with the default constructor, that all values are 0 (but w should be 1)
		TEST_METHOD(Default_Constructor_All_0)
		{
			Quaternion q;
			Assert::IsTrue(Vector4d(0, 0, 0, 1) == q.GetRawValues());

			return;
		}

		// Tests that getting and setting raw values works
		TEST_METHOD(Can_Set_Get_Raw_Values)
		{
			// Test 1000 times
			for (std::size_t i = 0; i < 1000; i++)
			{
				Vector4d v(
					rng() % 90,
					rng() % 90,
					rng() % 90,
					rng() % 90
				);

				Quaternion q(Vector4d(0, 0, 0, 0)); // Garbage values
				
				q.SetRawValues(v);
				Assert::IsTrue(v.Similar(q.GetRawValues()));
			}

			return;
		}

		// Tests that retreiving euler angles (without gimbal lock) results in the same values as put in
		TEST_METHOD(To_Euler_From_Euler)
		{
			// Test 1000 times
			for (std::size_t i = 0; i < 1000; i++)
			{
				// Create vector
				Vector3d eul(
					rng() % 90,
					rng() % 90,
					rng() % 90
				);

				// Create quaternion from vector
				Quaternion q(eul);

				// Create debug output
				std::wstringstream wss;
				wss << std::endl
					<< "Actual vals: " << q.ToEulerAngles() << std::endl
					<< "Target vals: " << eul << std::endl;

				// Assertion
				Assert::IsTrue(eul.Similar(q.ToEulerAngles()), wss.str().c_str());
			}

			return;
		}

		// Tests that adding angles (0,0,0) does not modify the quaternion
		TEST_METHOD(Add_Angles_0_Does_Nothing)
		{
			Quaternion a(Vector3d(0, -45, 45));
			Quaternion b(Vector3d(0, 0, 0));

			Assert::IsTrue(Vector3d(0, -45, 45).Similar((a * b).ToEulerAngles()));

			return;
		}

		// Tests that subtracting angles (0,0,0) does not modify the quaternion
		TEST_METHOD(Sub_Angles_0_Does_Nothing)
		{
			Quaternion a(Vector3d(0, -45, 45));
			Quaternion b(Vector3d(0, 0, 0));

			Assert::IsTrue(Vector3d(0, -45, 45).Similar((a / b).ToEulerAngles()));

			return;
		}

		// Tests that subtracting by itself always returns (0,0,0)
		TEST_METHOD(Sub_Itself_Is_0)
		{
			// Run test 100 times
			for (std::size_t i = 0; i < 100; i++)
			{
				Quaternion a(Vector3d(LARGE_RAND_DOUBLE, LARGE_RAND_DOUBLE, LARGE_RAND_DOUBLE));
				Assert::IsTrue(Vector3d(0,0,0).Similar((a / a).ToEulerAngles()));
			}

			return;
		}

		// These tests are kind of dumb, but the best ones i could come up with after days of tinkering.
		// I ended up manually testing the class. It is known to work.
		// These tests use values generated by a known-good state of the class to test its future versions.

		// Tests for rotation multiplication on x axis
		TEST_METHOD(Oracle_KnownGood_Mult_RotationX)
		{
			// Setup
			Quaternion a(Vector3d(39, 0, 0));
			Quaternion b(Vector3d(-100, 0, 0));

			// Exercise
			Quaternion r = a * b;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: -0.507538  y: 0  z: 0  w: 0.861629)" << std::endl
				<< L"Actual: " << r.GetRawValues() << std::endl;

			//    Assertion
			Assert::IsTrue(
				r.GetRawValues().Similar(Vector4d(-0.507538, 0, 0, 0.861629)),
				wss.str().c_str()
			);

			return;
		}

		// Tests for rotation multiplication on y axis
		TEST_METHOD(Oracle_KnownGood_Mult_RotationY)
		{
			// Setup
			Quaternion a(Vector3d(0, 12, 0));
			Quaternion b(Vector3d(0, -99, 0));

			// Exercise
			Quaternion r = a * b;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: 0  y: -0.688355  z: 0  w: 0.725374)" << std::endl
				<< L"Actual: " << r.GetRawValues() << std::endl;

			//    Assertion
			Assert::IsTrue(
				r.GetRawValues().Similar(Vector4d(0, -0.688355, 0, 0.725374)),
				wss.str().c_str()
			);

			return;
		}

		// Tests for rotation multiplication on z axis
		TEST_METHOD(Oracle_KnownGood_Mult_RotationZ)
		{
			// Setup
			Quaternion a(Vector3d(0, 0, -11));
			Quaternion b(Vector3d(0, 0, 69));

			// Exercise
			Quaternion r = a * b;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: 0  y: 0  z: 0.48481  w: 0.87462)" << std::endl
				<< L"Actual: " << r.GetRawValues() << std::endl;

			//    Assertion
			Assert::IsTrue(
				r.GetRawValues().Similar(Vector4d(0, 0, 0.48481, 0.87462)),
				wss.str().c_str()
			);

			return;
		}

		// Tests for rotation multiplication on xy axis
		TEST_METHOD(Oracle_KnownGood_Mult_RotationXY)
		{
			// Setup
			Quaternion a(Vector3d(39, -33, 0));
			Quaternion b(Vector3d(-100, 6, 0));

			// Exercise
			Quaternion r = a * b;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: -0.499894  y: -0.226807  z: -0.0969482  w: 0.83022)" << std::endl
				<< L"Actual: " << r.GetRawValues() << std::endl;

			//    Assertion
			Assert::IsTrue(
				r.GetRawValues().Similar(Vector4d(-0.499894, -0.226807, -0.0969482, 0.83022)),
				wss.str().c_str()
			);

			return;
		}

		// Tests for rotation multiplication on yz axis
		TEST_METHOD(Oracle_KnownGood_Mult_RotationYZ)
		{
			// Setup
			Quaternion a(Vector3d(0, 15, 12));
			Quaternion b(Vector3d(0, 13, -69));

			// Exercise
			Quaternion r = a * b;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: -0.0306713  y: 0.197249  z: -0.479632  w: 0.854462)" << std::endl
				<< L"Actual: " << r.GetRawValues() << std::endl;

			//    Assertion
			Assert::IsTrue(
				r.GetRawValues().Similar(Vector4d(-0.0306713, 0.197249, -0.479632, 0.854462)),
				wss.str().c_str()
			);

			return;
		}

		// Tests for rotation multiplication on xz axis
		TEST_METHOD(Oracle_KnownGood_Mult_RotationXZ)
		{
			// Setup
			Quaternion a(Vector3d(12, 0, 12));
			Quaternion b(Vector3d(-22, 0, -69));

			// Exercise
			Quaternion r = a * b;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: -0.0887439  y: 0.157186  z: -0.452873  w: 0.873111)" << std::endl
				<< L"Actual: " << r.GetRawValues() << std::endl;

			//    Assertion
			Assert::IsTrue(
				r.GetRawValues().Similar(Vector4d(-0.0887439, 0.157186, -0.452873, 0.873111)),
				wss.str().c_str()
			);

			return;
		}

		// Tests for rotation multiplication on xyz axis
		TEST_METHOD(Oracle_KnownGood_Mult_RotationXYZ)
		{
			// Setup
			Quaternion a(Vector3d(12, 45, 12));
			Quaternion b(Vector3d(-22, -16, -69));

			// Exercise
			Quaternion r = a * b;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: -0.391902  y: 0.319449  z: -0.391018  w: 0.769071)" << std::endl
				<< L"Actual: " << r.GetRawValues() << std::endl;

			//    Assertion
			Assert::IsTrue(
				r.GetRawValues().Similar(Vector4d(-0.391902, 0.319449, -0.391018, 0.769071)),
				wss.str().c_str()
			);

			return;
		}

		// Tests for rotation division on x axis
		TEST_METHOD(Oracle_KnownGood_Div_RotationX)
		{
			// Setup
			Quaternion a(Vector3d(133, 0, 0));
			Quaternion b(Vector3d(79, 0, 0));

			// Exercise
			Quaternion r = a / b;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: 0.45399  y: 0  z: 0  w: 0.891007)" << std::endl
				<< L"Actual: " << r.GetRawValues() << std::endl;

			//    Assertion
			Assert::IsTrue(
				r.GetRawValues().Similar(Vector4d(0.45399, 0, 0, 0.891007)),
				wss.str().c_str()
			);

			return;
		}

		// Tests for rotation division on y axis
		TEST_METHOD(Oracle_KnownGood_Div_RotationY)
		{
			// Setup
			Quaternion a(Vector3d(0, 12, 0));
			Quaternion b(Vector3d(0, -77, 0));

			// Exercise
			Quaternion r = a / b;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: 0  y: 0.700909  z: 0  w: 0.71325)" << std::endl
				<< L"Actual: " << r.GetRawValues() << std::endl;

			//    Assertion
			Assert::IsTrue(
				r.GetRawValues().Similar(Vector4d(0, 0.700909, 0, 0.71325)),
				wss.str().c_str()
			);

			return;
		}

		// Tests for rotation division on z axis
		TEST_METHOD(Oracle_KnownGood_Div_RotationZ)
		{
			// Setup
			Quaternion a(Vector3d(0, 0, -62));
			Quaternion b(Vector3d(0, 0, 115));

			// Exercise
			Quaternion r = a / b;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: 0  y: 0  z: -0.999657  w: 0.0261769)" << std::endl
				<< L"Actual: " << r.GetRawValues() << std::endl;

			//    Assertion
			Assert::IsTrue(
				r.GetRawValues().Similar(Vector4d(0, 0, -0.999657, 0.0261769)),
				wss.str().c_str()
			);

			return;
		}

		// Tests for rotation division on xy axis
		TEST_METHOD(Oracle_KnownGood_Div_RotationXY)
		{
			// Setup
			Quaternion a(Vector3d(88, 35, 0));
			Quaternion b(Vector3d(-21, -6, 0));

			// Exercise
			Quaternion r = a / b;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: 0.788184  y: 0.203366  z: -0.203838  w: 0.543928)" << std::endl
				<< L"Actual: " << r.GetRawValues() << std::endl;

			//    Assertion
			Assert::IsTrue(
				r.GetRawValues().Similar(Vector4d(0.788184, 0.203366, -0.203838, 0.543928)),
				wss.str().c_str()
			);

			return;
		}

		// Tests for rotation division on yz axis
		TEST_METHOD(Oracle_KnownGood_Div_RotationYZ)
		{
			// Setup
			Quaternion a(Vector3d(0, 11, -54));
			Quaternion b(Vector3d(0, -11, 32));

			// Exercise
			Quaternion r = a / b;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: 0.0364081  y: 0.187303  z: -0.669468  w: 0.717917)" << std::endl
				<< L"Actual: " << r.GetRawValues() << std::endl;

			//    Assertion
			Assert::IsTrue(
				r.GetRawValues().Similar(Vector4d(0.0364081, 0.187303, -0.669468, 0.717917)),
				wss.str().c_str()
			);

			return;
		}

		// Tests for rotation division on xz axis
		TEST_METHOD(Oracle_KnownGood_Div_RotationXZ)
		{
			// Setup
			Quaternion a(Vector3d(12, 0, 12));
			Quaternion b(Vector3d(-22, 0, -69));

			// Exercise
			Quaternion r = a * b;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: -0.0887439  y: 0.157186  z: -0.452873  w: 0.873111)" << std::endl
				<< L"Actual: " << r.GetRawValues() << std::endl;

			//    Assertion
			Assert::IsTrue(
				r.GetRawValues().Similar(Vector4d(-0.0887439, 0.157186, -0.452873, 0.873111)),
				wss.str().c_str()
			);

			return;
		}

		// Tests for rotation division on xyz axis
		TEST_METHOD(Oracle_KnownGood_Div_RotationXYZ)
		{
			// Setup
			Quaternion a(Vector3d(-12, 11, -113));
			Quaternion b(Vector3d(112, -21, 98));

			// Exercise
			Quaternion r = a / b;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: -0.855172  y: 0.243106  z: -0.414307  w: -0.194756)" << std::endl
				<< L"Actual: " << r.GetRawValues() << std::endl;

			//    Assertion
			Assert::IsTrue(
				r.GetRawValues().Similar(Vector4d(-0.855172, 0.243106, -0.414307, -0.194756)),
				wss.str().c_str()
			);

			return;
		}

		// Tests transforming 3d points. A few tests with different values.
		TEST_METHOD(Transform_Point_1)
		{
			// Setup
			Quaternion a(Vector3d(4.33, -1.23, 0.76));
			Vector3d p_raw(4.34, -1.22, 4.64);

			// Exercise
			Vector3d p_tr = a * p_raw;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: 4.26207  y: -1.51044  z: 4.62676)" << std::endl
				<< L"Actual: " << p_tr << std::endl;

			//    Assertion
			Assert::IsTrue(
				p_tr.Similar(Vector3d(4.26207, -1.51044, 4.62676), 0.001),
				wss.str().c_str()
			);

			return;
		}

		TEST_METHOD(Transform_Point_2)
		{
			// Setup
			Quaternion a(Vector3d(4.98, 4.01, 0.54));
			Vector3d p_raw(-2.04, -3.42, 0.82);

			// Exercise
			Vector3d p_tr = a * p_raw;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: -1.96577  y: -3.49695  z: 0.661406)" << std::endl
				<< L"Actual: " << p_tr << std::endl;

			//    Assertion
			Assert::IsTrue(
				p_tr.Similar(Vector3d(-1.96577, -3.49695, 0.661406), 0.001),
				wss.str().c_str()
			);

			return;
		}

		TEST_METHOD(Transform_Point_3)
		{
			// Setup
			Quaternion a(Vector3d(-0.35, -1.2, -4.41));
			Vector3d p_raw(-1.5, -3.8, -3.69);

			// Exercise
			Vector3d p_tr = a * p_raw;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: -1.71259  y: -3.70174  z: -3.69733)" << std::endl
				<< L"Actual: " << p_tr << std::endl;

			//    Assertion
			Assert::IsTrue(
				p_tr.Similar(Vector3d(-1.71259, -3.70174, -3.69733), 0.001),
				wss.str().c_str()
			);

			return;
		}

		TEST_METHOD(Transform_Point_4)
		{
			// Setup
			Quaternion a(Vector3d(-0.35, 2.04, -0.49));
			Vector3d p_raw(1.39, 1.95, -3.64);

			// Exercise
			Vector3d p_tr = a * p_raw;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: 1.27556  y: 1.91689  z: -3.69901)" << std::endl
				<< L"Actual: " << p_tr << std::endl;

			//    Assertion
			Assert::IsTrue(
				p_tr.Similar(Vector3d(1.27556, 1.91689, -3.69901), 0.001),
				wss.str().c_str()
			);

			return;
			return;
		}

		TEST_METHOD(Transform_Point_5)
		{
			// Setup
			Quaternion a(Vector3d(3.37, 2.63, -0.38));
			Vector3d p_raw(-4.19, 3.83, -4.55);

			// Exercise
			Vector3d p_tr = a * p_raw;

			// Verify
			//    Create debug message
			std::wstringstream wss;
			wss
				<< L"Expected: " << L"(x: -4.35645  y: 4.11983  z: -4.12018)" << std::endl
				<< L"Actual: " << p_tr << std::endl;

			//    Assertion
			Assert::IsTrue(
				p_tr.Similar(Vector3d(-4.35645, 4.11983, -4.12018), 0.001),
				wss.str().c_str()
			);

			return;
		}

		// Tests that rotational matrix generation works. Two tests with two different value sets
		TEST_METHOD(Transform_Matrix_1)
		{
			// Setup
			Quaternion a(Vector3d(-1.36, -1.44, 1.74));

			// Exercise
			Matrix4x4 m = a.ToRotationMatrix();

			// Verify
			Assert::IsTrue(Similar(m.a, 0.999223, 0.01));
			Assert::IsTrue(Similar(m.b, 0.0303545, 0.01));
			Assert::IsTrue(Similar(m.c, 0.0251301, 0.01));
			Assert::IsTrue(Similar(m.d, 0, 0.01));
			Assert::IsTrue(Similar(m.e, -0.0297593, 0.01));
			Assert::IsTrue(Similar(m.f, 0.999275, 0.01));
			Assert::IsTrue(Similar(m.g, -0.0237268, 0.01));
			Assert::IsTrue(Similar(m.h, 0, 0.01));
			Assert::IsTrue(Similar(m.i, -0.0258321, 0.01));
			Assert::IsTrue(Similar(m.j, 0.0229605, 0.01));
			Assert::IsTrue(Similar(m.k, 0.999403, 0.01));
			Assert::IsTrue(Similar(m.l, 0, 0.01));
			Assert::IsTrue(Similar(m.m, 0, 0.01));
			Assert::IsTrue(Similar(m.n, 0, 0.01));
			Assert::IsTrue(Similar(m.o, 0, 0.01));
			Assert::IsTrue(Similar(m.p, 0, 0.01));

			return;
		}

		TEST_METHOD(Transform_Matrix_2)
		{
			// Setup
			Quaternion a(Vector3d(-4.67, -0.94, 0.18));

			// Exercise
			Matrix4x4 m = a.ToRotationMatrix();

			// Verify
			Assert::IsTrue(Similar(m.a, 0.99986, 0.01));
			Assert::IsTrue(Similar(m.b, 0.00314116, 0.01));
			Assert::IsTrue(Similar(m.c, 0.0164054, 0.01));
			Assert::IsTrue(Similar(m.d, 0, 0.01));
			Assert::IsTrue(Similar(m.e, -0.00179549, 0.01));
			Assert::IsTrue(Similar(m.f, 0.996679, 0.01));
			Assert::IsTrue(Similar(m.g, -0.0814057, 0.01));
			Assert::IsTrue(Similar(m.h, 0, 0.01));
			Assert::IsTrue(Similar(m.i, -0.0166066, 0.01));
			Assert::IsTrue(Similar(m.j, 0.0813649, 0.01));
			Assert::IsTrue(Similar(m.k, 0.996546, 0.01));
			Assert::IsTrue(Similar(m.l, 0, 0.01));
			Assert::IsTrue(Similar(m.m, 0, 0.01));
			Assert::IsTrue(Similar(m.n, 0, 0.01));
			Assert::IsTrue(Similar(m.o, 0, 0.01));
			Assert::IsTrue(Similar(m.p, 0, 0.01));

			return;
		}

		// Tests that a *= b will result in the exact same outcome as a = a * b
		TEST_METHOD(MultiplyEquals_Operator_Same_Result_As_Multiply_Operator)
		{
			// Run tests 1000 times
			for (std::size_t i = 0; i < 1000; i++)
			{
				// Setup
				Quaternion a(Vector3d(rng() % 360, rng() % 360, rng() % 360));
				Quaternion b(Vector3d(rng() % 360, rng() % 360, rng() % 360));
				
				// Exercise
				Quaternion ref = a * b;
				a *= b;

				// Verify
				Assert::IsTrue(a.GetRawValues().Similar(ref.GetRawValues()));
			}

			return;
		}

		// Tests that a /= b will result in the exact same outcome as a = a / b
		TEST_METHOD(DivideEquals_Operator_Same_Result_As_Divide_Operator)
		{
			// Run tests 1000 times
			for (std::size_t i = 0; i < 1000; i++)
			{
				// Setup
				Quaternion a(Vector3d(rng() % 360, rng() % 360, rng() % 360));
				Quaternion b(Vector3d(rng() % 360, rng() % 360, rng() % 360));

				// Exercise
				Quaternion ref = a / b;
				a /= b;

				// Verify
				Assert::IsTrue(a.GetRawValues().Similar(ref.GetRawValues()));
			}

			return;
		}

		// Tests basic equals comparison -> true
		TEST_METHOD(Basic_EqualsComparison_True)
		{
			// Run tests 1000 times
			for (std::size_t i = 0; i < 1000; i++)
			{
				// Setup
				Vector3d e(rng() % 360, rng() % 360, rng() % 360);
				Quaternion a(e);
				Quaternion b(e);

				// Exercise and verify
				Assert::IsTrue(a == b);
			}

			return;
		}

		// Tests basic equals comparison -> true
		TEST_METHOD(Basic_EqualsComparison_False)
		{
			// Run tests 1000 times
			for (std::size_t i = 0; i < 1000; i++)
			{
				// Setup
				Vector3d ae(rng() % 360, rng() % 360, rng() % 360);
				Vector3d be(rng() % 360, rng() % 360, rng() % 360);

				// Abort if both vectors are equal
				if (ae == be)
				{
					i--;
					continue;
				}

				Quaternion a(ae);
				Quaternion b(be);

				// Exercise and verify
				Assert::IsFalse(a == b);
			}

			return;
		}

		// Tests that different euler angles return true, if the angle is the same.
		// Like [30, -10, 59] == [390, 350, 419]
		TEST_METHOD(Equals_Comparison_Same_Rotation_Different_EulerAngles)
		{
			// Run tests 1000 times
			for (std::size_t i = 0; i < 1000; i++)
			{
				// Setup
				//    Create random rotation
				Vector3d ae(rng() % 360, rng() % 360, rng() % 360);
				
				// add or subtract a random multiple of 360
				#define keep_rot_change_values (360.0 * (double)(rng() % 20) * ((rng()%2) ? 1.0 : -1.0))
				Vector3d be(ae.x + keep_rot_change_values, ae.y + keep_rot_change_values, ae.z + keep_rot_change_values);
				#undef keep_rot_change_values

				// Create quaternions
				Quaternion a(ae);
				Quaternion b(be);

				// Exercise & Verify
				//    Create debug output

				std::wstringstream wss;
				wss << "ae: " << ae << std::endl
					<< "be: " << be << std::endl
					<< "a: " << a << std::endl
					<< "b: " << b << std::endl;

				//    Assertion
				Assert::IsTrue(a == b, wss.str().c_str());
			}

			return;
		}

		// Tests basic not-equals comparison -> false
		TEST_METHOD(Basic_NotEqualsComparison_False)
		{
			// Run tests 1000 times
			for (std::size_t i = 0; i < 1000; i++)
			{
				// Setup
				Vector3d e(rng() % 360, rng() % 360, rng() % 360);
				Quaternion a(e);
				Quaternion b(e);

				// Exercise and verify
				Assert::IsFalse(a != b);
			}

			return;
		}

		// Tests basic not-equals comparison -> true
		TEST_METHOD(Basic_NotEqualsComparison_True)
		{
			// Run tests 1000 times
			for (std::size_t i = 0; i < 1000; i++)
			{
				// Setup
				Vector3d ae(rng() % 360, rng() % 360, rng() % 360);
				Vector3d be(rng() % 360, rng() % 360, rng() % 360);

				// Abort if both vectors are equal
				if (ae == be)
				{
					i--;
					continue;
				}

				Quaternion a(ae);
				Quaternion b(be);

				// Exercise and verify
				Assert::IsTrue(a != b);
			}

			return;
		}
	};
}
